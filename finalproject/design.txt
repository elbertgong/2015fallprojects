I chose to implement a chess final project because I had really enjoyed the game of 15 pset, and I wanted to try something similar but taken to the next level. However, chess was far more difficult than I had imagined. The nickname "gangster chess" was given to the project because, in its early stages, it was being very uncooperative and not following the rules. The bugs were later fixed, but the nickname stuck.

The game starts with the homepage, index.html. Pressing the play button submits a form to newgame.php. In newgame.php, we first include some other php files, global.php and helpers.php. global.php allows me to use superglobal variables. I want to be able to keep track of the position of chessboard throughout different php files, and I accomplish this by storing two variables, $board and $turns, superglobally as $_SESSION["board"] and $_SESSION["turns"]. helpers.php gives me access to the render function, inspired by cs50 pset 7's render.

The most important variable in the whole game is $board. $board is a 9*9 array which will keep track of the locations of the pieces. Each piece is represented by an associative array with several key-value pairs to denote its properties: ascii, white, and piece. An empty square was denoted with no ascii value and piece="empty". newgame.php stores each piece in one of the locations in $board. For example, to store a black rook in the upper-right corner of the board, I would do $board[1][1] = $blackrook; where $blackrook = ["ascii" => "&#9820;", "white" => false, "piece" => "rook"]; . Then, after storing the updated board superglobally, I use the render function to render playchess.php, the html view that actually displays the board.

playchess.php first tells you whose turn it is, using the latest information from the superglobal turns variable. Then, it displays the chessboard in table format. The idea of using an html table (and some of the accompanying CSS) was inspired by http://designindevelopment.com/css/css3-chess-board/. However, their chessboard is simply a static board, so I dynamically insert html into the table by using the <?= ?> syntax and putting in the appropriate ascii values, which are stored in $board. Then I display two forms. The first form lets you submit a move for approval by the gangster overlords. The second form lets you end the game, bringing you to winscreen.php, where you can press a button to start a new game.

When you submit a move for approval by the gangster overlords, the form relays (by POST) the coordinates of your original square and your destination square to islegalmove.php. islegalmove.php is where a lot of the chess-logic takes place. First, islegalmove.php retrieves the latest $board and $turns information. Then, it takes the coordinates relayed to it by POST and explodes them into two arrays. $original[0] is the x-coordinate of the original square, $original[1] is the y-coordinate of the original square, $destination[0] is the x-coordinate of the destination square, and $destination[1] is the y-coordinate of the destination square. I also create some other variables, called $origsquare and $destsquare, for convenience. The overall goal of islegalmove.php is to determine whether you can legally move a piece from the original square to the destination square. If it is illegal, the piece is not moved, and we render playchess.php without updating the board. If it is legal, we update the board using the move function in helpers.php.

islegalmove.php starts by checking whether there's an actual piece on the original square. If there isn't, then the move is invalid. If the piece is white and it's black's turn (or vice versa), the move is also invalid. 
            If the original piece is a white pawn, then you check whether the destination square is one row above the original square, and whether the original square is empty. (If it's on the penultimate row, go ahead and promote that pawn by changing it to a queen.) If it's on the beginning row, it also has the option of moving forward two squares, if both squares are empty. If there is a black piece diagonally in front of it, it can also capture that piece (and here you also want to check whether the pawn is promoting itself). If none of these conditions are satisfied, then the move must be illegal.
            If the original piece is a black pawn, you follow a similar logic to the white pawn section, except everything is inverted.
            If the original piece is a knight, then you want to check whether the destination square is one of the eight locations that a knight can legally move to, and if so, then go ahead and move the knight to that square. If not, then the move is illegal.
            If the original piece is a bishop, the logic is a little more complicated. You want to check whether the destination square is along one of the four diagonals. But if it is, you need a nested for-loop to check whether there are any obstructing pieces (non-empty squares) along that diagonal between the original square and the destination square. If there is an obstruction, then the move isn't legal. If the destination square was not found along one of these diagonals, then the move isn't legal.
            If the original piece is a rook, you follow the same logic, except that instead of checking along the diagonals you want to check along the vertical and horizontal rows and columns.
            If the original piece is a queen, you combine the logic of a bishop and the logic of a rook, since a queen can move like either a bishop or a rook.
            If the original piece is a king, you check whether the destination square is in one of the eight adjacent squares. However, you also need to check whether the king is castling (that is, white king moving from E1 to G1 or C1, or black king moving from E8 to G8 or C8). If you are castling, then some trickery is needed. First you move the rook over to the appropriate square, manually changing the $board array. Then, you use the move function to move the king.
            
islegalmove.php has repeatedly been calling a function called move. This function is located in helpers.php, and it works as follows: first it checks to make sure you aren't capturing your own piece. Then it makes sure you aren't capturing a king, because that's also illegal. Then, it updates $board, making the original square empty and storing your original piece in the destination square. It also keeps track of what was in the destination square beforehand, using a variable called $temp. Then it uses the function iswhitechecked or isblackchecked to see whether the move has put white or black into check, respectively (depending on whose turn it is). If you've put yourself into check, then the move is illegal, so it is necessary to restore the original board position. That's why we had the variable $temp! If you haven't put yourself into check, then we increase $turns by 1 and store the updated $board and $turns superglobally.

The only thing left are two very similar functions, isblackchecked and iswhitechecked. Let's look at isblackchecked. 
            First, it uses a simple nested for-loop to determine the location of the black king and store its coordinates in $row and $column. Then we look for any white pieces that could be attacking this king. If any legitimate attacker is found, we return true.
            First we look for pawns in the adjacent diagonal-lower squares. 
            Then we look for knights in one of the eight squares a knight-jump away from the king. (FYI, we use isset just to make sure we're not looking for some square outside the board that doesn't exist. For instance, if the king is on the lowest row, there's no reason to be checking the square 2 rows down and 1 column to the left of it.
            Then we look for bishops and queens along the diagonals. Along each diagonal, we use a for-loop to check each successive square. However, there are 2 extra conditions. If a square isn't set, then we know we're looking at a square that's off the board, and there's no need to check any further. If a square is nonempty, then that piece blocks the potential check of the bishop or queen, and there's no need to check any further.
            Then we look for rooks and queens the same way we looked along the diagonals, but now we are looking along the horizontal rows and vertical columns, not the diagonals.
            Then we look for kings in the eight adjacent squares.
            If we haven't found any attackers by now, then black isn't being checked, and we can return false.
            
iswhitechecked operates in a very similar fashion to isblackchecked, except the directional checking of pawns is inverted, and we look for black attackers instead of white ones.

And that's it! You can now play a game of chess, under the strict supervision of the gangster overlords.